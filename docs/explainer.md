# MiniApp Packaging Explainer

> Note: This document serves as a supplementary explanation of the [MiniApp Packaging](https://w3c.github.io/miniapp/specs/packaging/) spec. If there is any inconsistency with the spec, you should consider the spec to be authoritative.

## Authors

- Yongjing Zhang (Huawei)
- Martin Alvarez (Huawei)

## 1. Introduction

### What is this?

A MiniApp Package is a [ZIP](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)-based container file that wraps a set of files (JS code, components, resources, configurations, styles) comprising the whole MiniApp.

It can be delivered to a user agent through different channels (e.g., web, app store, offline), then rendered/executed by the hosting platform.

### Why should we care?

A MiniApp Package contains all necessary information used by a user agent to properly check, load, and execute the MiniApp. A standardized format is essential so that a MiniApp package generated by different developers or tools can be deployed on various hosting platforms (e.g., super-apps and native-OS frameworks) in a compatible and consistent way. 

The spec shall define the following aspects to ensure interoperability:
* the minimum set of files for a MiniApp to be runnable;
* the optional files for enhanced features;
* a well-defined file and directory structure;
* pre-defined file names and naming convention;
* parsing and validity check mechanism;
* the overall file format (and extension name) of the package;
* the corresponding MIME type for internet exchange.

## 2. MiniApp Package Design

### The Package File Format

Following the common practice of mobile app packaging (such as Android APK), the MiniApp package is designed as a specialized ZIP file, which has its file extension name (`.ma`) and a dedicated MIME type (`application/miniapp-pkg+zip` - to be registered with IANA).

The package can be treated as a regular `.zip` file in some cases (i.e., a ZIP parser may open and read the MiniApp package without following the MiniApp Packaging spec). However, having the dedicated file extension name and MINE Type gives a way for a hosting platform or a package loader to do pre-checking or content-type negotiation before loading/downloading the package.

### The Package Content

A MiniApp package requires a homogeneous file system organization:

* **manifest.json**: A JSON-based file responsible for the global configuration of the app, as an extension of the Web App Manifest. (See [MiniApp Manifest](https://www.w3.org/TR/miniapp-manifest/)) 
* **app.js**: Document with scripts defining the main application logic and responsible for the life-cycle management (see [MiniApp Lifecycle](https://www.w3.org/TR/miniapp-lifecycle/))
* **app.css**: The global/default application stylesheet.
* **pages**: A reserved directory that contains all page-related resources. It may have sub-directories to organize different pages. Each page may have the following associated files:
  * ***.js**:  The page scripts (i.e., app logic of the page)
  * ***.html**: The page layout (the concrete format is [under discussion](https://github.com/w3c/miniapp-packaging/issues/2))
  * ***.json**: An optional page-specific configuration.
  * ***.css**: The page-specific style
* **common**: A reserved directory that contains common resources (i.e., images, scripts, UI components, templates) that can be (re)used by one or multiple MiniApp pages/widgets. It may have sub-directories for an efficient organization. (Details are for further study.)

> Note: As the MiniApp Packaging spec is still under development, the content listed above is not complete yet and is subject to further change.

### Security Considerations

A MiniApp package should guarantee integrity and trustworthiness in the app distribution. So, a MiniApp package may include one or more digital signatures with integrity mechanisms and certificates that enable verifying authors (e.g., the MiniApp developer) and distributors (e.g., an application marketplace). (See more details in the [spec](https://www.w3.org/TR/miniapp-packaging/#sec-miniapp-digital-signature-requirements))

User agents may require specific digital signature mechanisms, depending on the use case and MiniApp environment, so the specification does not recommends concrete encryption methods or technologies. The specification will include informative examples of various technologies to be used, such as [RFC5652](https://tools.ietf.org/html/rfc5652) (PKCS#7) and the [APK Signature Scheme v2 (https://source.android.com/security/apksigning/v2)).


## 3. Sample

One typical illustrative example of a MiniApp package is given in the [spec](https://www.w3.org/TR/miniapp-packaging/#example-file-system-structure).

## 4. Comparison with Other Packaging Technologies

There are already some other packaging technologies specified for different purposes, such as [Widgets (obsolete)](https://www.w3.org/TR/widgets), [WICG WebPackage (WPACK)](https://github.com/WICG/webpackage) and its [obsolete version](https://www.w3.org/TR/2015/WD-web-packaging-20150115/), and [Lightweight Packaging Format (LPF)](https://www.w3.org/TR/lpf/). They are designed based on different archive formats (e.g., ZIP and CBOR) and use different signature mechanisms (e.g., [XMLDSIG](http://www.w3.org/TR/xmldsig-core1/)-based, HTTP-based), and contain different types of contents (e.g., web pages, HTTP exchanges, digital publications). Such differences result from the diversity of the environment assumptions and the technical requirements of individual technologies.

The MiniApp package also has unique assumptions and requirements that cannot be addressed directly by existing technologies. It is essentially a mobile application container, designed to pack all required application materials (e.g., pages, layouts, UI components, resources, scripts, and configurations) to be deployed and executed by various application user agents (e.g., "Mini Program" [[1]](https://smartprogram.baidu.com/developer/index.html)[[2]](https://open.alipay.com/channel/miniIndex.htm)[[3]](https://mp.weixin.qq.com/cgi-bin/wx) and [Quick App](https://www.quickapp.cn/)), rather than to pack web contents or digital publications to be loaded by browsers or e-book readers. 

The following analysis summarizes the main reasons why **existing packaging technologies cannot meet the needs of MiniApp packaging**:

1. **[WPACK](https://github.com/WICG/webpackage):** It is intended to pack a collection of web resources in terms of HTTP exchanges (including HTTP requests, responses, signatures, and other metadata) so that a browser can load them locally and recover the web transaction states securely without accessing the origin. To achieve this, an HTTP-specific signature mechanism is defined, which is apparently not suitable for MiniApp, which does not rely on HTTP exchanges. Moreover, WPACK proposes to define a new CBOR-based archive format instead of using ZIP for web-specific [reasons](https://github.com/WICG/webpackage/issues/45) that do not apply to MiniApp. For instance, ZIP resources are file-based, so they are not efficient for HTTP response headers in WPACK but can serve MiniApp very well and are already used widely in mobile application packaging implementations (e.g., Android APK, QuickApp, MiniProgram). 
2. **[Web Package (obsolete)](https://www.w3.org/TR/2015/WD-web-packaging-20150115/):** It is an unfinished work as the ancestor of WPACK. It chooses not to use ZIP but defines a new Streamable Package Format for specific reasons that are not seen by MiniApp. Again, it is designed as closely coupled with HTTP (headers) which is not suitable for MiniApp.
3. **[Widgets (obsolete)](https://www.w3.org/TR/widgets):** It is an old implementation of Packaged Web Apps called Widgets. It is ZIP-based but has specific file/folder structure and naming constraints, and it uses XML-based configuration documents. These constraints are not compatible with MiniApp. In addition, it uses [XMLDSIG](http://www.w3.org/TR/xmldsig-core1/) for the digital signature, which can only protect the signed files but not the entire package file itself. One can add/remove signature files, add other files or blocks into the ZIP package, or alter the ZIP metadata without being noticed. Such vulnerability is not acceptable by MiniApp.
4. **[LPF](https://www.w3.org/TR/lpf/):** It is a lightweight ZIP-based packaging format that contains digital publication materials. It mandates publication-specific files (i.e., `publication.json`, `index.html`) that are not needed by a MiniApp, while misses MiniApp specific files like `manifest.json` and `app.js`. Also, it does not cover the security concerns, such as the integrity protection of the whole package that a MiniApp addresses.

The following table shows a detailed comparison between a MiniApp package and other packaging technologies


Technology | Client Platform | Content | Web Dependency | Format | Digital Signature 
:---    |:---    |:--        |:---   |:---    |:--   
MiniApp | Super-App, OS, or Browser* | Application-resources (e.g., app logics, page layouts, UI components â€“ not necessarily h5-based) | No (may or may not use web resources) | ZIP-based | PKCS#7 
WPACK | Browser | Web content (HTTP exchanges) | Yes (a web origin is always assumed, even offline) | CBOR-based | HTTP header extension 
WebPackage (old) | Browser | Web content | Yes (a web origin is always assumed, even offline) | Streamable Package Format (.pack) | n/a 
Widgets | Browser, OS | Widget files (html start files, XML configuration, icons ...) | No (may or may not use web resources) | ZIP-based | XMLDSIG-based 
LPF | e-Readers |  Digital publications, configuration | No | ZIP-based | unknown* 

> Note: `*` in the table above denotes the feature that is under discussion/development.

Although MiniApp leverages popular web front-end technologies like JavaScript and CSS, a MiniApp is closer to a native app than a snapshot of a web-content collection. Moreover, existing web packaging technologies cannot cover the requirements of MiniApp, so a dedicated MiniApp Packaging specification needs to be developed.

